### 4 可选操作 ###
#### 4.1 未获支持的操作 ####

- `Arrays.asList()`生成的`List`是基于一个固定大小的数组，仅支持哪些不会改变**数组大小**的操作；
- 将`Arrrays.asList()`的结果作为构造器的参数传递给任何`Collection`（或者使用`addAll()`，`Collections.addAll()`静态方法）则可以生成允许使用所有方法的普通容器；
- `Collections.unmodifiableList()`则不允许**修改容器**。

#### 6 Set和存储顺序 ####


- **HashSet**
为快速查找设计。存入`HashSet`的元素必须定义`hashCode()`。默认的选择。
- **TreeSet**
保持次序的`Set`，底层为树结构。使用它可从`Set`中提取有序的序列。元素必须实现`Comparable`接口。
- **LinkedHashSet**
具有`HashSet`的查询速度，且内部使用链表维护元素的顺序（插入次序）。在使用迭代器遍历`Set`时，会按元素插入的次序显示。元素必须定义`hashCode()`方法。

**Note**
在`compareTo()`中，使用`return i - i2`是一个常见的编程错误，在Java中可能会溢出，例如`i`是一个很大的正数而`i2`是一个很大的负数。

### 8 理解Map ###
- **HashMap**
默认
- **LinkedHashMap**
类似于`HashMap`,但在遍历时，取得“键值对”的顺序是插入次序或者是最近最少（LRU）次序。
- **TreeMap**
基于红黑树的实现。唯一带有`subMap()`方法的Map，可以返回一个子树。
- **WeakHashMap**
如果映射之外没有引用指向某个“键”，则此“键”可以被GC回收
- **ConcurrentHashMap**
一种线程安全的Map
- **IdentityHashMap**
使用`==`代替`equals()`对“键”进行比较的散列映射
