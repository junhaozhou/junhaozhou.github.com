---
layout: post
title: "[Java] Thinking in Java 第21章 并发"
categories: [Java]
tags: [Java]
fullview: false
comments: true
---
### 1 并发的多面性 ###

#### 1.1 更快的执行 ####

- 并发通常是提高运行在**单处理器**上的程序的性能
- 需要并发是因为**阻塞**
- 从性能角度看，如果没有任务会阻塞，那么在单处理器机器上使用并发就没有意义

### 2 基本的线程机制 ###

#### 2.3 使用Executor ####

- `CachedThreadPool`通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程。
- `FixedThreadPool`可以限制线程的数量
- `SingleThreadPool`就像是数量为**1**的`FixedThreadPool`,如果向`SingleThreadPool`提交了多个任务，这些任务将排队
- 在任何线程池中，现有线程在有可能的情况下，都会被自动复用

#### 2.4 从任务中产生返回值 ####

在 **Java SE5** 中引入`Callable`是一种具有类型参数的泛型，它的类型参数表示的是从方法`call()`中返回的值，并且必须使用`ExecutorService.submit()`方法调用

#### 2.8 后台线程 ####

- 后台（daemon）线程是在程序运行时在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。
- 必须在线程启动之前调用`setDaemon()`方法，才能把它设置为后台线程

#### 2.13 线程组 ####

> 继续错误的代价由别人来承担，而承认错误的代价由自己承担

#### 2.14 捕获异常 ####

`Thread.UncaughtExceptionHandler`会在线程因未捕获的异常而临近死亡时被调用

### 3 共享受限资源 ###

#### 3.1 不正确地访问资源 ####

在Java中，递增不是原子操作。如果不保护任务，即使单一的递增也是不安全的。

#### 3.2 解决共享资源竞争 ####

- 所有对象都自动含有单一的锁。当在对象上调用其任意`synchronized`方法的时候，此对象都被加锁，这时该对象上的其他`synchronized`方法只有等到前一个方法调用完毕并释放了锁之后才能被调用
- 一个任务可以多次获得对象的锁。如果一个方法在同一个对象上调用了第二个方法，后者又调用了同一个对象上的另一个方法，就会发生这种情况。JVM负责跟踪对象被加锁的次数。如果一个对象被解锁（即锁被完全释放），其计数变为0.在任务第一次给对象加锁的时候，计数变为1.每当这个相同的任务在这个对象上获得锁时，计数都会递增。显然，只有首先获得了锁的任务才能允许继续获取多个锁。每当任务离开一个`synchronized`方法，计数递减，当计数为零的时候，锁被完全释放，别的任务就可以使用此资源
- 针对每一个类，也有一个锁（作为类的Class对象的一部分），所以`synchronized static`方法可以在类的范围内防止对`static`数据的并发访问（**注：单例模式是么？**）
- *Brian的同步规则*：
> 如果你正在写一个变量，它可能接下来被另一个线程读取，或者正在读取上一个已经被另一个线程写过变量，那么你必须使用同步，并且，读写线程都必须使用相同的监视器锁同步

- 每个访问临界共享资源的方法都必须被同步，否则他们就不会正确的工作

##### 使用显式的Lock对象 #####

```java

```